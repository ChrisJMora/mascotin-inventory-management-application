# Nombre del workflow
name: Validación y Despliegue en Pull Request

# Descripción: Este workflow construye la aplicación Dockerizada, levanta la base de datos como servicio,
# ejecuta la aplicación en contenedor, espera que MySQL y la app estén listas y valida su correcto funcionamiento.

# Permisos mínimos necesarios para ejecutar el workflow
permissions:
  contents: read  # Solo lectura del repositorio

# Evento que activa el workflow
on:
  pull_request:
    branches:
      - main
    types:
      - opened
      - synchronize
      - reopened

# Cancelación de ejecuciones anteriores en el mismo PR para optimizar recursos
concurrency:
  group: pr-validation-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  build-run-validate:
    name: Construir, Ejecutar y Validar Contenedores
    runs-on: ubuntu-latest

    # Definir servicios Docker (MySQL) disponibles para este job
    services:
      db:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
          MYSQL_DATABASE: ${{ secrets.MYSQL_DATABASE }}
          MYSQL_USER: ${{ secrets.MYSQL_USER }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping --silent"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      # Paso 1: Clonar el repositorio para obtener el código fuente
      - name: Checkout del código
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Paso 2: Configurar Docker Buildx para optimizar la construcción de imágenes
      - name: Configurar Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Paso 3: Construir la imagen Docker de la aplicación desde el Dockerfile
      - name: Construir imagen Docker de la aplicación
        run: docker build -t mascotin-inventory-management-application .

      # Paso 4: Ejecutar la aplicación en un contenedor enlazando con el servicio MySQL
      - name: Ejecutar contenedor de la aplicación
        run: |
          docker run -d \
            --name app \
            -p 8080:8080 \
            --env MYSQL_HOST=db \
            --env MYSQL_USER=${{ secrets.MYSQL_USER }} \
            --env MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }} \
            --env MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }} \
            --network host \
            mascotin-inventory-management-application

      # Paso 5: Esperar a que el servicio MySQL esté listo mediante healthcheck
      - name: Esperar a que MySQL esté saludable
        run: |
          for i in {1..30}; do
            STATUS=$(docker inspect --format='{{json .State.Health.Status}}' $(docker ps -qf "name=db") || echo "\"unhealthy\"")
            if [[ "$STATUS" == "\"healthy\"" ]]; then
              echo "MySQL está listo"
              exit 0
            fi
            echo "Esperando a MySQL... ($i)"
            sleep 5
          done
          echo "MySQL no se puso saludable a tiempo"
          exit 1

      # Paso 6: Esperar a que la aplicación responda en puerto 8080
      - name: Esperar a que la aplicación responda
        run: |
          for i in {1..30}; do
            if curl --fail http://localhost:8080/health; then
              echo "Aplicación está lista"
              exit 0
            fi
            echo "Esperando a la aplicación... ($i)"
            sleep 5
          done
          echo "La aplicación no respondió en el tiempo esperado"
          exit 1

      # Paso 7: Validar que la base de datos existe dentro del contenedor MySQL
      - name: Validar existencia de base de datos
        run: |
          docker exec $(docker ps -qf "name=db") \
            mysql -u${{ secrets.MYSQL_USER }} -p${{ secrets.MYSQL_PASSWORD }} \
            -e "SHOW DATABASES;" | grep ${{ secrets.MYSQL_DATABASE }}

      # Paso 8: Validar que la aplicación responda correctamente a HTTP
      - name: Validar respuesta HTTP de la aplicación
        run: |
          curl --fail http://localhost:8080 || (echo "La aplicación no responde correctamente" && exit 1)

      # Paso 9: Apagar contenedores para limpiar el ambiente
      - name: Apagar contenedor de la aplicación
        if: always()
        run: |
          docker rm -f app
