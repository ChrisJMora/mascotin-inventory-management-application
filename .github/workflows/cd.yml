# Nombre del workflow
name: Validación y Despliegue en Pull Request

# Permisos mínimos necesarios
permissions:
  contents: read  # Solo lectura del repositorio

# Evento que activa este workflow
on:
  pull_request:
    branches:
      - main
    types:
      - opened
      - synchronize
      - reopened

# Evita ejecuciones paralelas innecesarias en el mismo Pull Request
concurrency:
  group: pr-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:

  build-containers:
    name: Creación de Contenedores Docker
    runs-on: ubuntu-latest

    steps:
      # Clonar el repositorio
      - name: Clonar el repositorio
        uses: actions/checkout@v4

      # Configurar Docker Buildx para compilación avanzada
      - name: Configurar Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Crear archivo .env con las variables necesarias
      - name: Crear archivo .env
        run: |
          echo "MYSQL_USER=${{ secrets.MYSQL_USER }}" > .env
          echo "MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}" >> .env
          echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" >> .env
          echo "MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}" >> .env

      # Construir imágenes Docker definidas en docker-compose.yml
      - name: Construir imágenes Docker
        run: docker compose build

  run-containers:
    name: Levantar contenedores en segundo plano
    runs-on: ubuntu-latest
    needs: build-containers

    steps:
      # Clonar el repositorio nuevamente
      - name: Clonar el repositorio
        uses: actions/checkout@v4

      # Crear archivo .env con variables necesarias (incluyendo MYSQL_HOST)
      - name: Crear archivo .env
        run: |
          echo "MYSQL_USER=${{ secrets.MYSQL_USER }}" > .env
          echo "MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}" >> .env
          echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" >> .env
          echo "MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}" >> .env
          echo "MYSQL_HOST=db" >> .env

      # Descargar script wait-for-it para posibles esperas si quieres
      - name: Descargar script wait-for-it
        run: |
          curl -o wait-for-it.sh https://raw.githubusercontent.com/vishnubob/wait-for-it/master/wait-for-it.sh
          chmod +x wait-for-it.sh

      # Levantar contenedores en modo detached
      - name: Levantar contenedores con Docker Compose
        run: docker compose up -d

  validate-services:
    name: Validación y Espera Activa de Servicios
    runs-on: ubuntu-latest
    needs: run-containers

    steps:
      # Mostrar contenedores activos para diagnóstico
      - name: Listar contenedores activos
        run: docker ps

      # Esperar activamente a que la aplicación responda en localhost:8080
      - name: Esperar a que la aplicación esté disponible en puerto 8080
        run: |
          for i in {1..30}; do
            if curl --fail http://localhost:8080/health; then
              echo "Aplicación lista y responde"
              exit 0
            fi
            echo "Esperando aplicación... intento $i"
            sleep 5
          done
          echo "Error: la aplicación no respondió a tiempo"
          exit 1

      # Mostrar logs de la aplicación para depuración si falla
      - name: Mostrar logs de la aplicación
        if: failure()
        run: docker logs $(docker ps -qf "name=mascotin-inventory-management-application-app")

      # Mostrar logs de MySQL para depuración
      - name: Mostrar logs de MySQL
        if: failure()
        run: docker logs $(docker ps -qf "name=mascotin-inventory-management-application-db")

      # Validar que la base de datos existe dentro del contenedor db
      - name: Verificar existencia de base de datos
        run: |
          docker exec $(docker ps -qf "name=mascotin-inventory-management-application-db") \
            mysql -u${{ secrets.MYSQL_USER }} -p${{ secrets.MYSQL_PASSWORD }} \
            -e "SHOW DATABASES;" | grep ${{ secrets.MYSQL_DATABASE }}

      # Apagar contenedores siempre al finalizar las validaciones
      - name: Apagar contenedores
        if: always()
        run: docker compose down
