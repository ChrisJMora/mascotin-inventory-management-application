# Nombre del workflow
name: Validación y Despliegue en Pull Request

# Permisos mínimos necesarios
permissions:
  contents: read  # Solo lectura del repositorio

# Evento que activa este workflow
on:
  pull_request:
    branches:
      - main
    types:
      - opened
      - synchronize
      - reopened

# Evita ejecuciones paralelas innecesarias en el mismo Pull Request
concurrency:
  group: pr-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:

  # Job para construir las imágenes Docker
  build-containers:
    name: Creación de Contenedores Docker
    runs-on: ubuntu-latest

    steps:
      # Clonar el repositorio
      - name: Clonar el repositorio
        uses: actions/checkout@v4

      # Configurar Docker Buildx para build avanzado
      - name: Configurar Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Crear archivo .env con variables secretas necesarias
      - name: Crear archivo .env
        run: |
          echo "MYSQL_USER=${{ secrets.MYSQL_USER }}" > .env
          echo "MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}" >> .env
          echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" >> .env
          echo "MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}" >> .env

      # Construir las imágenes Docker según docker-compose.yml
      - name: Construir imágenes Docker
        run: docker compose build

  # Job que levanta contenedores, valida servicios y apaga contenedores
  run-and-validate:
    name: Levantar y Validar Servicios Docker
    runs-on: ubuntu-latest
    needs: build-containers  # Depende que se haya completado el build

    steps:
      # Clonar el repositorio
      - name: Clonar el repositorio
        uses: actions/checkout@v4

      # Crear archivo .env con variables secretas (igual que en build)
      - name: Crear archivo .env
        run: |
          echo "MYSQL_USER=${{ secrets.MYSQL_USER }}" > .env
          echo "MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}" >> .env
          echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" >> .env
          echo "MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}" >> .env
          echo "MYSQL_HOST=db" >> .env

      # Descargar script wait-for-it para esperas condicionales
      - name: Descargar script wait-for-it
        run: |
          curl -o wait-for-it.sh https://raw.githubusercontent.com/vishnubob/wait-for-it/master/wait-for-it.sh
          chmod +x wait-for-it.sh

      # Levantar contenedores en segundo plano
      - name: Iniciar contenedores con Docker Compose
        run: docker compose up -d

      # Esperar que MySQL esté disponible en el puerto 3306 (puerto mapeado a localhost)
      - name: Esperar a MySQL
        run: ./wait-for-it.sh localhost:3306 --timeout=120 --strict -- echo "MySQL disponible"

      # Esperar que la aplicación esté disponible en el puerto 8080
      - name: Esperar a la Aplicación
        run: ./wait-for-it.sh localhost:8080 --timeout=180 --strict -- echo "Aplicación disponible"

      # Listar los contenedores activos para debug
      - name: Listar contenedores activos
        run: docker ps

      # Validar que la aplicación responde HTTP correctamente
      - name: Validar respuesta HTTP de la aplicación
        run: |
          curl --fail http://localhost:8080 || (echo "La aplicación no responde correctamente" && exit 1)

      # Validar que la base de datos fue creada correctamente
      - name: Verificar existencia de base de datos
        run: |
          docker exec $(docker ps -qf "name=db") \
            mysql -u${{ secrets.MYSQL_USER }} -p${{ secrets.MYSQL_PASSWORD }} \
            -e "SHOW DATABASES;" | grep ${{ secrets.MYSQL_DATABASE }}

      # Apagar los contenedores siempre, incluso si fallan las validaciones
      - name: Apagar contenedores
        if: always()
        run: docker compose down
