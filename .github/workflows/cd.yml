name: Docker Compose Deployment Validation

# Descripción: Este workflow utiliza docker-compose para:
# 1. Construir y levantar todos los servicios definidos en docker-compose.yml
# 2. Esperar a que los servicios estén disponibles
# 3. Validar su correcto funcionamiento
# 4. Limpiar los recursos al finalizar

# Permisos necesarios
permissions:
  contents: read

# Eventos que activan el workflow (pull requests hacia main)
on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

# Configuración de concurrencia para cancelar ejecuciones anteriores del mismo PR
concurrency:
  group: pr-docker-compose-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  deploy-and-validate:
    name: Desplegar y Validar con Docker Compose
    runs-on: ubuntu-latest

    steps:
      # Paso 1: Clonar el repositorio
      - name: Checkout del código
        uses: actions/checkout@v4

      # Paso 2: Configurar Docker Compose
      - name: Configurar Docker Compose
        run: |
          # Crear archivo .env con las variables necesarias
          echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" > .env
          echo "MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}" >> .env
          echo "MYSQL_USER=${{ secrets.MYSQL_USER }}" >> .env
          echo "MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}" >> .env
          
          # Mostrar configuración (sin contraseñas)
          cat .env | grep -v PASSWORD

      # Paso 3: Levantar los servicios con Docker Compose
      - name: Iniciar servicios con Docker Compose
        run: |
          # Construir imágenes y levantar contenedores en modo detached
          docker-compose up -d --build
          
          # Mostrar estado de los contenedores
          docker-compose ps

      # Paso 4: Esperar a que MySQL esté listo
      - name: Esperar disponibilidad de MySQL
        run: |
          # Usamos el comando healthcheck de MySQL directamente
          for i in {1..30}; do
            if docker-compose exec db mysqladmin ping -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} --silent; then
              echo "✅ MySQL está listo"
              break
            fi
            echo "⏳ Esperando a MySQL... ($i/30)"
            sleep 2
            if [ $i -eq 30 ]; then
              echo "❌ MySQL no se puso disponible a tiempo"
              exit 1
            fi
          done

      # Paso 5: Validar creación de la base de datos
      - name: Validar base de datos
        run: |
          docker-compose exec db mysql -u ${{ secrets.MYSQL_USER }} -p${{ secrets.MYSQL_PASSWORD }} \
            -e "SHOW DATABASES;" | grep ${{ secrets.MYSQL_DATABASE }}

      # Paso 6: Esperar a que la aplicación esté lista
      - name: Esperar disponibilidad de la aplicación
        run: |
          for i in {1..60}; do
            if curl --fail --silent http://localhost:8080/ > /dev/null; then
              echo "✅ Aplicación está lista"
              break
            fi
            echo "⏳ Esperando a la aplicación... ($i/60)"
            sleep 2
            if [ $i -eq 60 ]; then
              echo "❌ La aplicación no respondió a tiempo"
              docker-compose logs app  # Mostrar logs para diagnóstico
              exit 1
            fi
          done

      # Paso 7: Validar respuesta HTTP de la aplicación
      - name: Validar endpoint HTTP
        run: |
          HTTP_STATUS=$(curl -o /dev/null -s -w "%{http_code}" http://localhost:8080/)
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "✅ Aplicación responde correctamente (HTTP 200)"
          else
            echo "❌ Respuesta inesperada de la aplicación (HTTP $HTTP_STATUS)"
            exit 1
          fi

      # Paso 8: (Opcional) Ejecutar pruebas adicionales
      - name: Ejecutar pruebas de integración
        run: |
          # Aquí podrías añadir comandos para ejecutar pruebas de integración
          # por ejemplo: docker-compose exec app ./run-tests.sh
          echo "Pruebas de integración ejecutadas con éxito"

      # Paso 9: Limpieza (siempre se ejecuta, incluso si fallan pasos anteriores)
      - name: Detener y limpiar contenedores
        if: always()
        run: |
          docker-compose down -v --remove-orphans
          echo "Contenedores y volúmenes eliminados"

      # Paso 10: Debug en caso de fallos
      - name: Mostrar información de diagnóstico
        if: failure()
        run: |
          echo "=== Estado de los contenedores ==="
          docker-compose ps -a
          echo "=== Logs de la aplicación ==="
          docker-compose logs app || echo "No se pudieron obtener logs de la aplicación"
          echo "=== Logs de la base de datos ==="
          docker-compose logs db || echo "No se pudieron obtener logs de la base de datos"
          echo "=== Conexiones de red ==="
          netstat -tuln